<<<<<<< HEAD
# Scenario VII: large effect, unknown variance

## Details

In this scenario, we investigate the scenario of a large effect with unknown common variance $sigma$. The test statistics then follow a $t$-distribution. For a large sample size, the $t$-distribution can be approximated by the normal distribution and we find ourselves in [Scenario I](#scenarioI).
The larger the assumed effect size in the alternative, the lower the necessary number of subjects to achieve possible restraints on the power. Thus, we choose an effect size of $\delta=1.2$ with point prior distribution. The null hypothesis is given by $\mathcal{H}_0: \delta \leq 0$. The maximal type one error is bounded by $\alpha=0.025$ and at the point alternative of $\delta=1.2$ the power should be at least $0.8$. 

```{r}
#data distributions and hypothesis
datadist <- Student(two_armed=TRUE)
H_0 <- PointMassPrior(.0,1)
prior <- PointMassPrior(1.2,1)

#define constraints
alpha <- 0.025
min_power <- 0.8
toer_cnstr <- Power(datadist,H_0)<= alpha
pow_cnstr <- Power(datadist,prior) >= min_power
```

## Variant VII-1: Minimizing Expected Sample Size under Point Prior {#variantVII_1}

### Objective

Firstly, we minimize the expected sample size under the alternative, e.g. $\boldsymbol{E}\big[n(\mathcal{D})\big]$.
```{r}
ess <- ExpectedSampleSize(datadist,prior)
```

### Constraints

No additional constraints beside type one error rate and power are considered in this variant.

### Initial Designs

For this example, the optimal one-stage, group-sequential, and generic two-stage designs are computed. The initial design for the one-stage case is determined heuristically. Both the group sequential and the generic two-stage designs are optimized starting from the corresponding group-sequential design as computed by the `rpact` package.

=======
#Scenario VII: binomial distribution, Gaussian prior {#scenarioVII}

## Details

In this scenario, we revisit the case from [ScenarioVI](#variantVI), but are not assuming a point prior anymore. Instead, a Gaussian prior with mean $\theta = 0.4$ and variance $\tau^2 = 0.2^2$ on the effect size is assumed. 

In order to fulfill regulatory considerations, the type one error rate is still protected under the point prior $\delta=0$ at the level of significance $\alpha=0.025$.

The power constraint, however, needs to be modified. It is not senseful to compute the power as rejection probability under the full prior, because effect sizes less than a minimal clinically relevant effect do not show (sufficient) evidence againt the null hypothesis. Therefore, we assume a minimal clinically relevant effect size $\delta=0.0$ and condition the prior on values $\delta>0$ to compute expected power. In the following, the expected power should be at least $0.8$. 

```{r}
# data distribution and priors
datadist   <- Normal(two_armed = TRUE)
H_0        <- PointMassPrior(.0, 1)
prior      <- ContinuousPrior(function(delta) dnorm(delta, mean = .4, sd = .2),
                              support = c(-5, 5),
                              tighten_support = TRUE)

# define constraints on type one error rate and expected power
alpha      <- 0.025
min_epower <- 0.8
toer_cnstr <- Power(datadist, H_0) <= alpha
epow_cnstr <- Power(datadist, condition(prior, c(0.0, prior@support[2]))) >= min_epower
```

## Variant VII-1: Minimizing Expected Sample Size under Point Prior{#scenarioVII_1}

### Objective
Expected sample size under the full prior is minimized, i.e., $\boldsymbol{E}\big[n(\mathcal{D})\big]$.
```{r}
ess <- ExpectedSampleSize(datadist, prior)
```

### Constraints
No additional constraints are considered in this variant.

### Initial Design
For this example, the optimal one-stage, group-sequential, and generic two-stage designs are computed. While the initial design for the one-stage case is determined heuristically, both the group sequential and the generic two-stage designs are optimized starting from the a group-sequential design that is computed by the `rpact`package to fulfill the type one error rate constraint and that fulfills the power constraint at an effect size of $\delta=0.3$. 

```{r}
order <- 5L
# data frame of initial designs 
tbl_designs <- tibble(
    type    = c("one-stage", "group-sequential", "two-stage"),
    initial = list(
        OneStageDesign(250, 2.0),
        rpact_design(datadist, 0.3, 0.025, 0.8, TRUE, order),
        TwoStageDesign(rpact_design(datadist, 0.3, 0.025, 0.8, TRUE, order))) )
```
The order of integration is set to 5.

### Optimization
>>>>>>> d4dc86bfc9aa60dd3b22d208f1aefb2aa92a3806
```{r}
tbl_designs <- tbl_designs %>% 
    mutate(
       optimal = purrr::map(initial, ~minimize(
         
          ess,
          subject_to(
              toer_cnstr,
<<<<<<< HEAD
              pow_cnstr
=======
              epow_cnstr
>>>>>>> d4dc86bfc9aa60dd3b22d208f1aefb2aa92a3806
          ),
          
          initial_design = ., 
          opts           = opts)) )
```

### Test Cases
<<<<<<< HEAD

To avoid improper solutions, it is first verified that the maximum number of iterations was not exceeded in any of the three cases.

=======
Firstly, it is checked that the maximum number of iterations was not reached in all these cases.
>>>>>>> d4dc86bfc9aa60dd3b22d208f1aefb2aa92a3806
```{r}
tbl_designs %>% 
  transmute(
      type, 
      iterations = purrr::map_int(tbl_designs$optimal, 
                                  ~.$nloptr_return$iterations) ) %>%
  {print(.); .} %>% 
  {testthat::expect_true(all(.$iterations < opts$maxeval))}
```

<<<<<<< HEAD
Next, the type one error rate and power constraints are verified for all three designs by simulation:
=======

Since type one error rate is defined under the point effect size  $\delta=0$, the type one error rate constraint can be tested for all three optimal designs.
>>>>>>> d4dc86bfc9aa60dd3b22d208f1aefb2aa92a3806

```{r}
tbl_designs %>% 
  transmute(
      type, 
<<<<<<< HEAD
      toer  = purrr::map(tbl_designs$optimal, 
                         ~sim_pr_reject(.[[1]], .0, datadist)$prob), 
      power = purrr::map(tbl_designs$optimal, 
                         ~sim_pr_reject(.[[1]], .4, datadist)$prob) ) %>% 
  unnest(., cols = c(toer, power)) %>% 
  {print(.); .} %>% {
  testthat::expect_true(all(.$toer  <= alpha * (1 + tol)))
  #testthat::expect_true(all(.$power >= min_power * (1 - tol))) 
}

```

The $n_2$ function of the optimal two-stage design is expected to be monotonously decreasing:

```{r}
expect_true(
    all(diff(
        # get optimal two-stage design n2 pivots
        tbl_designs %>% filter(type == "two-stage") %>%
           {.[["optimal"]][[1]]$design@n2_pivots} 
        ) < 0) )
```

Since the optimal two-stage design is more flexible than the optimal group-sequential design (constant  
$n_2$ function) and this is more flexible than the optimal one-stage design (no second stage), the expected sample sizes under the prior should be ordered in the opposite way. Additionally, expected sample sizes under the null hypothesis are computed both via `evaluate()` and simulation-based.

```{r}
tbl_designs %>% 
    mutate(
        ess      = map_dbl(optimal,
                           ~evaluate(ess, .$design) ),
        ess_sim  = map_dbl(optimal,
                           ~sim_n(.$design, .4, datadist)$n ),
        ess0     = map_dbl(optimal,
                           ~evaluate(ess0, .$design) ),
        ess0_sim = map_dbl(optimal,
                           ~sim_n(.$design, .0, datadist)$n ) ) %>% 
    {print(.); .} %>% {
    # sim/evaluate same under alternative?
    testthat::expect_equal(.$ess, .$ess_sim, 
                           tolerance = tol_n,
                           scale = 1)
    # sim/evaluate same under null?
    testthat::expect_equal(.$ess0, .$ess0_sim, 
                           tolerance = tol_n,
                           scale = 1)
    # monotonicity with respect to degrees of freedom
    #testthat::expect_true(all(diff(.$ess) < 0)) 
}
```

The expected sample size under the alternative must be lower or equal than the expected sample size of the initial `rpact` group-sequential design that is based on the inverse normal combination test.

```{r}
testthat::expect_lte(
  evaluate(ess, 
             tbl_designs %>% 
                filter(type == "group-sequential") %>% 
                pull(optimal) %>% 
                .[[1]]  %>%
                .$design ),
    evaluate(ess, 
             tbl_designs %>% 
                filter(type == "group-sequential") %>% 
                pull(initial) %>% 
                .[[1]] ) )
=======
      toer = purrr::map(tbl_designs$optimal, 
                        ~sim_pr_reject(.[[1]], .0, datadist)$prob) ) %>% 
  unnest(., cols = c(toer)) %>% 
  {print(.); .} %>% {
  testthat::expect_true(all(.$toer <= alpha * (1 + tol))) }
```
Since the optimal two-stage design is more flexible than the optimal group-sequential design (constant $n_2$ function) and this is more flexible than the optimal one-stage design (no second stage), the expected sample sizes under the prior should be ordered in the opposite way. Additionally, expected sample sizes under the null hypothesis are computed both via `evaluate()` and simulation-based.

```{r}
essh0 <- ExpectedSampleSize(datadist, H_0)

tbl_designs %>% 
    mutate(
        ess       = map_dbl(optimal,
                            ~evaluate(ess, .$design) ),
        essh0     = map_dbl(optimal,
                            ~evaluate(essh0, .$design) ),
        essh0_sim = map_dbl(optimal,
                            ~sim_n(.$design, .0, datadist)$n ) ) %>% 
    {print(.); .} %>% {
    # sim/evaluate same under null?
    testthat::expect_equal(.$essh0, .$essh0_sim, 
                           tolerance = tol_n,
                           scale = 1)
    # monotonicity with respect to degrees of freedom
    testthat::expect_true(all(diff(.$ess) < 0)) }
>>>>>>> d4dc86bfc9aa60dd3b22d208f1aefb2aa92a3806
```

