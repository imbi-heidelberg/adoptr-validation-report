bookdown::render_book("index.Rmd", output_format = "all")
install.packages("bookdown")
bookdown::render_book("index.Rmd", output_format = "all")
install.packages(c("adoptr", "tidyverse", "bookdown", "rpact", "testthat", "pwr", "tinytex"))
install.packages(c("adoptr", "tidyverse", "bookdown", "rpact", "testthat", "pwr", "tinytex"))
install.packages(c("adoptr", "tidyverse", "bookdown", "rpact", "testthat", "pwr", "tinytex"))
install.packages(c("adoptr", "tidyverse", "bookdown", "rpact", "testthat", "pwr", "tinytex"))
bookdown::render_book("index.Rmd", output_format = "all")
library(stats)
?dnorm
library(adoptr)
?ContinuousPrior
bookdown::render_book(c("index.Rmd","07-scenario-VII.Rmd"), output_format = "all")
library(bookdown)
bookdown::render_book(c("index.Rmd","07-scenario-VII.Rmd"), output_format = "all")
bookdown::render_book("index.Rmd", output_format = "all")
bookdown::render_book("temp.Rmd", output_format = "all")
bookdown::render_book("temp.Rmd", output_format = "all")
bookdown::render_book(c("index.Rmd","07-scenario-VII.Rmd"), output_format = "all", preview=TRUE)
bookdown::render_book(c("07-scenario-VII.Rmd"), output_format = "all", preview=TRUE)
bookdown::render_book(temp.Rmd, output_format = "all", preview=TRUE)
bookdown::render_book("temp.Rmd", output_format = "all", preview=TRUE)
bookdown::render_book("temp.Rmd", output_format = "all", preview=TRUE)
bookdown::render_book("index.Rmd",output_format = "all")
# data distribution and hypotheses
datadist   <- Binomial(rate_control = 0.3, two_armed = TRUE)
bookdown::render_book("index.Rmd",output_format = "all")
bookdown::render_book("index.Rmd",output_format = "all")
bookdown::render_book("index.Rmd",output_format = "all")
seq(0,1,1000)
d <- seq(0,1,1000)
d
?seq
d <- deq(0,1,by=1000)
d <- seq(0,1,by=1000)
d
seq(0,1,0.001)
d <- seq(0,1,0.001)
plot(dbeta(d,2,4))
plot(d,dbeta(d,2,4))
plot(d,dbeta(d,2,3))
plot(d,dbeta(d,2,2))
plot(d,dbeta(d,2,2.5))
plot(d,dbeta(d,2,4))
plot(d,dbeta(d,7,5))
?condition
plot(d,dbeta(d,7,5))
?condition
?dbeta
?ContinuousPrior
library(adoptr)
x <- seq(1,100,0.01)
x
x <- seq(0,1,0.01)
x
y <- dbeta(x,7,5)
plot(x,y)
x <- seq(0,1,0.001)
y <- dbeta(x,7,5)
plot(x,y)
plot(x,y,type="l")
plot(x,y,type="l",col="red")
dbeta(0,7,5)
dbeta(1,7,5)
?ExpectedSampleSize
?Power
bookdown::render_book("index.Rmd",ouput_format="all")
bookdown::render_book("index.Rmd",output_format="all")
library(adoptr)
opts = list(
algorithm = "NLOPT_LN_COBYLA",
xtol_rel  = 1e-5,
maxeval   = 100000
)
rpact_design <- function(
dist, effect, sig.level = 0.025, power = 0.8, two_armed = TRUE, order = 5L) {
design_rp <- rpact::getDesignInverseNormal(
kMax = 2,
alpha = sig.level,
beta = 1 - power,
futilityBounds = 0,
typeOfDesign = "P"
)
if (is(dist, "Normal")) {
res <- rpact::getSampleSizeMeans(
design_rp, normalApproximation = TRUE, alternative = effect * ifelse(
two_armed, 1, sqrt(2)
)
)
} else if (is(dist, "Binomial")) {
res <- rpact::getSampleSizeRates(
design_rp, groups = 2, normalApproximation = TRUE,
pi1 = dist@rate_control, pi2 = dist@rate_control + effect
)
} else {
break("Specified data distribution does not exist in adoptr!")
}
char <- rpact::getDesignCharacteristics(design_rp)
n1 <- res$numberOfSubjects1[1,]
n2 <- res$numberOfSubjects1[2,]
c2_rp <- function(z){
w1 <- 1 / sqrt(2)
w2 <- sqrt(1 - w1^2)
out <- (design_rp$criticalValues[2] - w1 * z) / w2
return(out)
}
c1f <- ifelse(is(dist, "Normal"), stats::qnorm(char$futilityProbabilities) +
sqrt(res$numberOfSubjects1[1]) * effect / ifelse(two_armed, sqrt(2), 1),
design_rp$futilityBounds)
c1e <- design_rp$criticalValues[1]
rpact_design <- adoptr::GroupSequentialDesign(
ceiling(n1),
c1f,
c1e,
ceiling(n2),
rep(2.0, order)
)
rpact_design@c2_pivots <- sapply(adoptr:::scaled_integration_pivots(rpact_design), c2_rp)
return(rpact_design)
}
datadist   <- Binomial(rate_control=0.3, two_armed = TRUE)
H_0        <- PointMassPrior(.0, 1)
prior      <- ContinuousPrior(function(x) dbeta(x, shape1=7,shape2=5),
support = c(0.0,1.0),
tighten_support = TRUE)
alpha      <- 0.025
min_epower <- 0.8
toer_cnstr <- Power(datadist, H_0) <= alpha
epow_cnstr <- Power(datadist, condition(prior, c(0.3,1.0))) >= min_epower
?minimize
ess <- ExpectedSampleSize(datadist, prior)
onestage <- OneStageDesign(200,2)
results <- minimize(ess,subject_to(toer_cnstr,epow_cnstr),initial_design = onestage,opts=opts)
onestage <- OneStageDesign(200,0.5)
results <- minimize(ess,subject_to(toer_cnstr,epow_cnstr),initial_design = onestage,opts=opts)
onestage <- OneStageDesign(200,40)
results <- minimize(ess,subject_to(toer_cnstr,epow_cnstr),initial_design = onestage,opts=opts)
groupsequential <- OneStageDesign(200,40)
results <- minimize(ess,subject_to(toer_cnstr,epow_cnstr),initial_design = groupsequential,opts=opts)
groupsequential <- rpact_design(datadist,0.3,0.025,0.8,TRUE,7L)
results <- minimize(ess,subject_to(toer_cnstr,epow_cnstr),initial_design = groupsequential,opts=opts)
alpha      <- 0.025
min_epower <- 0.8
toer_cnstr <- Power(datadist, H_0) <= alpha
epow_cnstr <- Power(datadist, prior) >= min_epower
ess <- ExpectedSampleSize(datadist, prior)
groupsequential <- rpact_design(datadist,0.3,0.025,0.8,TRUE,7L)
results <- minimize(ess,subject_to(toer_cnstr,epow_cnstr),initial_design = groupsequential,opts=opts)
bookdown::render_book("index.Rmd",output_format="all")
datadist <- Student(two_armed=TRUE)
group_seq <- rpact_design(datadist, 1.2, 0.025, 0.8, TRUE, order)
group_seq <- rpact_design(datadist, 0.7, 0.025, 0.8, TRUE, order)
datadist <- Normal(two_armed=TRUE)
group_seq <- rpact_design(datadist, 0.4, 0.025, 0.8, TRUE, order)
datadist <- Normal(two_armed=TRUE)
group_seq <- rpact_design(datadist, 0.4, 0.025, 0.8, TRUE, 7L)
datadist <- Student(two_armed=TRUE)
group_seq <- rpact_design(datadist, 0.4, 0.025, 0.8, TRUE, 7L)
datadist <- Hello(two_armed=TRUE)
datadist <- Student(two_armed=TRUE)
group_seq <- rpact_design(datadist, 0.4, 0.025, 0.8, TRUE, 7L)
group_seq <- rpact_design(hello, 0.4, 0.025, 0.8, TRUE, 7L)
group_seq <- rpact_design(Student, 0.4, 0.025, 0.8, TRUE, 7L)
?Student
datadist <- Student(two_armed=TRUE)
TwoStageDesign(rpact_design(datadist, 1.2, 0.025, 0.8, TRUE, order)))
TwoStageDesign(rpact_design(datadist, 1.2, 0.025, 0.8, TRUE, order))
?pull
x <- seq(0,1,0.001)
y <- dbeta(x,7,5)
plot(x,y)
y <- dbeta(x,4,8)
plot(x,y)
?ContinuousPrior
library(adoptr)
opts = list(
algorithm = "NLOPT_LN_COBYLA",
xtol_rel  = 1e-5,
maxeval   = 100000
)
rpact_design <- function(
dist, effect, sig.level = 0.025, power = 0.8, two_armed = TRUE, order = 5L) {
design_rp <- rpact::getDesignInverseNormal(
kMax = 2,
alpha = sig.level,
beta = 1 - power,
futilityBounds = 0,
typeOfDesign = "P"
)
if (is(dist, "Normal")) {
res <- rpact::getSampleSizeMeans(
design_rp, normalApproximation = TRUE, alternative = effect * ifelse(
two_armed, 1, sqrt(2)
)
)
} else if (is(dist, "Binomial")) {
res <- rpact::getSampleSizeRates(
design_rp, groups = 2, normalApproximation = TRUE,
pi1 = dist@rate_control, pi2 = dist@rate_control + effect
)
} else {
break("Specified data distribution does not exist in adoptr!")
}
char <- rpact::getDesignCharacteristics(design_rp)
n1 <- res$numberOfSubjects1[1,]
n2 <- res$numberOfSubjects1[2,]
c2_rp <- function(z){
w1 <- 1 / sqrt(2)
w2 <- sqrt(1 - w1^2)
out <- (design_rp$criticalValues[2] - w1 * z) / w2
return(out)
}
c1f <- ifelse(is(dist, "Normal"), stats::qnorm(char$futilityProbabilities) +
sqrt(res$numberOfSubjects1[1]) * effect / ifelse(two_armed, sqrt(2), 1),
design_rp$futilityBounds)
c1e <- design_rp$criticalValues[1]
rpact_design <- adoptr::GroupSequentialDesign(
ceiling(n1),
c1f,
c1e,
ceiling(n2),
rep(2.0, order)
)
rpact_design@c2_pivots <- sapply(adoptr:::scaled_integration_pivots(rpact_design), c2_rp)
return(rpact_design)
}
datadist   <- Binomial(rate_control=0.3, two_armed = TRUE)
H_0        <- PointMassPrior(.0, 1)
prior      <- ContinuousPrior(function(x) dbeta(x, shape1=4,shape2=8),
support = c(0.0,1.0),
tighten_support = TRUE)
alpha      <- 0.025
min_epower <- 0.8
toer_cnstr <- Power(datadist, H_0) <= alpha
epow_cnstr <- Power(datadist, condition(prior, c(0.0,0.7))) >= min_epower
ess <- ExpectedSampleSize(datadist, prior)
onestage <- OneStageDesign(200,2.0)
results <- minimize(ess,subject_to(toer_cnstr,epow_cnstr),initial_design = onestage,opts=opts)
prior      <- ContinuousPrior(function(x) dbeta(x, shape1=4,shape2=8),
support = c(0.0,0.7),
tighten_support = TRUE)
pbeta(0.7,4,8)
prior      <- ContinuousPrior(function(x) 1/(pbeta(0.7,4,8))*dbeta(x, shape1=4,shape2=8),
support = c(0.0,0.7),
tighten_support = TRUE)
results <- minimize(ess,subject_to(toer_cnstr,epow_cnstr),initial_design = onestage,opts=opts)
prior      <- ContinuousPrior(function(x) 1/(pbeta(0.7,4,8))*dbeta(x, shape1=4,shape2=8),
support = c(0.0,0.7),
tighten_support = TRUE)
ess <- ExpectedSampleSize(datadist, prior)
results <- minimize(ess,subject_to(toer_cnstr,epow_cnstr),initial_design = onestage,opts=opts)
datadist   <- Binomial(rate_control=0.3, two_armed = TRUE)
H_0        <- PointMassPrior(.0, 1)
prior      <- ContinuousPrior(function(x) 1/(pbeta(0.7,4,8))*dbeta(x, shape1=4,shape2=8),
support = c(0.0,0.7),
tighten_support = TRUE)
alpha      <- 0.025
min_epower <- 0.8
toer_cnstr <- Power(datadist, H_0) <= alpha
epow_cnstr <- Power(datadist, condition(prior, c(0.0,0.7))) >= min_epower
ess <- ExpectedSampleSize(datadist, prior)
onestage <- OneStageDesign(200,2.0)
results <- minimize(ess,subject_to(toer_cnstr,epow_cnstr),initial_design = onestage,opts=opts)
datadist   <- Binomial(rate_control=0.3, two_armed = TRUE)
H_0        <- PointMassPrior(.0, 1)
prior      <- ContinuousPrior(function(x) 1/(pbeta(0.6,4,8))*dbeta(x, shape1=4,shape2=8),
support = c(0.0,0.6),
tighten_support = TRUE)
alpha      <- 0.025
min_epower <- 0.8
toer_cnstr <- Power(datadist, H_0) <= alpha
epow_cnstr <- Power(datadist, condition(prior, c(0.0,0.6))) >= min_epower
ess <- ExpectedSampleSize(datadist, prior)
onestage <- OneStageDesign(200,2.0)
results <- minimize(ess,subject_to(toer_cnstr,epow_cnstr),initial_design = onestage,opts=opts)
datadist   <- Binomial(rate_control=0.3, two_armed = TRUE)
H_0        <- PointMassPrior(.0, 1)
prior      <- ContinuousPrior(function(x) 1/(pbeta(0.69,4,8))*dbeta(x, shape1=4,shape2=8),
support = c(0.0,0.69),
tighten_support = TRUE)
alpha      <- 0.025
min_epower <- 0.8
toer_cnstr <- Power(datadist, H_0) <= alpha
epow_cnstr <- Power(datadist, condition(prior, c(0.0,0.69))) >= min_epower
ess <- ExpectedSampleSize(datadist, prior)
onestage <- OneStageDesign(200,2.0)
results <- minimize(ess,subject_to(toer_cnstr,epow_cnstr),initial_design = onestage,opts=opts)
datadist   <- Binomial(rate_control=0.3, two_armed = TRUE)
H_0        <- PointMassPrior(.0, 1)
prior      <- ContinuousPrior(function(x) 1/(pbeta(0.6999,4,8))*dbeta(x, shape1=4,shape2=8),
support = c(0.0,0.6999),
tighten_support = TRUE)
alpha      <- 0.025
min_epower <- 0.8
toer_cnstr <- Power(datadist, H_0) <= alpha
epow_cnstr <- Power(datadist, condition(prior, c(0.0,0.6999))) >= min_epower
ess <- ExpectedSampleSize(datadist, prior)
onestage <- OneStageDesign(200,2.0)
results <- minimize(ess,subject_to(toer_cnstr,epow_cnstr),initial_design = onestage,opts=opts)
datadist   <- Binomial(rate_control=0.3, two_armed = TRUE)
H_0        <- PointMassPrior(.0, 1)
prior      <- ContinuousPrior(function(x) 1/(pbeta(0.7,4,8))*dbeta(x, shape1=4,shape2=8),
support = c(0.0,0.7),
tighten_support = TRUE)
alpha      <- 0.025
min_epower <- 0.8
toer_cnstr <- Power(datadist, H_0) <= alpha
epow_cnstr <- Power(datadist, condition(prior, c(0.0,0.7))) >= min_epower
ess <- ExpectedSampleSize(datadist, prior)
onestage <- OneStageDesign(200,2.0)
results <- minimize(ess,subject_to(toer_cnstr,epow_cnstr),initial_design = onestage,opts=opts)
x <- seq(0,1,0.001)
y <- dbeta(0,4,8)
plot(x,y)
y <- dbeta(x,4,8)
plot(x,y)
x
y <- dnorm(x,mean=0.3,sd=.2)
plot(x,y)
x <- seq(-1,1,0.001)
y <- dnorm(x,mean=0.3,sd=.2)
plot(x,y)
datadist   <- Binomial(rate_control=0.3, two_armed = TRUE)
H_0        <- PointMassPrior(.0, 1)
prior      <- ContinuousPrior(function(x) 1/(pnorm(0.7,0.3,0.2)-pnorm(-0.3,0.3,0.2))*dnrom(x,0.3,0.2),
support = c(-0.3,0.7),
tighten_support = TRUE)
alpha      <- 0.025
min_epower <- 0.8
toer_cnstr <- Power(datadist, H_0) <= alpha
epow_cnstr <- Power(datadist, condition(prior, c(0.0,0.7))) >= min_epower
ess <- ExpectedSampleSize(datadist, prior)
onestage <- OneStageDesign(200,2.0)
results <- minimize(ess,subject_to(toer_cnstr,epow_cnstr),initial_design = onestage,opts=opts)
datadist   <- Binomial(rate_control=0.3, two_armed = TRUE)
H_0        <- PointMassPrior(.0, 1)
prior      <- ContinuousPrior(function(x) 1/(pnorm(0.69,0.3,0.2)-pnorm(-0.29,0.3,0.2))*dnorm(x,0.3,0.2),
support = c(-0.29,0.69),
tighten_support = TRUE)
alpha      <- 0.025
min_epower <- 0.8
toer_cnstr <- Power(datadist, H_0) <= alpha
epow_cnstr <- Power(datadist, condition(prior, c(0.0,0.69))) >= min_epower
ess <- ExpectedSampleSize(datadist, prior)
onestage <- OneStageDesign(200,2.0)
results <- minimize(ess,subject_to(toer_cnstr,epow_cnstr),initial_design = onestage,opts=opts)
